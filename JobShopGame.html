<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Job Shop Scheduling Game</title>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  * {
    box-sizing: border-box;
  }

  body {
    font-family: "Inter", -apple-system, BlinkMacSystemFont, "Helvetica Neue", Helvetica, Arial, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    margin: 0;
    padding: 20px;
    min-height: 100vh;
  }

  .container {
    max-width: 1400px;
    margin: 0 auto;
  }

  .header {
    background: white;
    border-radius: 12px;
    padding: 20px 30px;
    margin-bottom: 20px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 20px;
  }

  .header h1 {
    margin: 0;
    color: #333;
    font-size: 28px;
    font-weight: 700;
  }

  .stats {
    display: flex;
    gap: 30px;
    align-items: center;
  }

  .stat {
    text-align: center;
  }

  .stat-label {
    font-size: 12px;
    color: #666;
    text-transform: uppercase;
    font-weight: 600;
    margin-bottom: 4px;
  }

  .stat-value {
    font-size: 24px;
    font-weight: 700;
    color: #667eea;
  }

  .game-area {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin-bottom: 20px;
  }

  .top-panels {
    display: grid;
    grid-template-columns: 300px 1fr;
    gap: 20px;
  }

  .bottom-panels {
    display: grid;
    grid-template-columns: 300px 1fr;
    gap: 20px;
  }

  .panel {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  }

  .panel h2 {
    margin: 0 0 15px 0;
    font-size: 18px;
    color: #333;
    font-weight: 600;
  }

  button {
    font-family: inherit;
    font-size: 14px;
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    background: #667eea;
    color: #fff;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s;
    width: 100%;
    margin-bottom: 10px;
  }

  button:hover {
    background: #5568d3;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
  }

  button:active {
    transform: translateY(0);
  }

  button.secondary {
    background: #f0f0f0;
    color: #333;
  }

  button.secondary:hover {
    background: #e0e0e0;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  }

  button.success {
    background: #10b981;
  }

  button.success:hover {
    background: #059669;
  }

  .level-select {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }

  .level-select button {
    margin: 0;
  }

  .jobs-queue {
    max-height: 400px;
    overflow-y: auto;
  }

  .job-card {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 10px;
    border-left: 4px solid;
    cursor: move;
    transition: all 0.2s;
  }

  .job-card:hover {
    transform: translateX(5px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }

  .job-card.scheduled {
    opacity: 0.5;
    cursor: default;
  }

  .job-card.scheduled:hover {
    transform: none;
  }

  .job-title {
    font-weight: 600;
    margin-bottom: 6px;
    font-size: 14px;
  }

  .operations {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
  }

  .operation {
    font-size: 11px;
    padding: 5px 10px;
    border-radius: 4px;
    background: white;
    border: 1px solid #ddd;
    white-space: nowrap;
    cursor: grab;
    transition: all 0.2s;
  }

  .operation:hover {
    background: #f0f0f0;
    transform: scale(1.05);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }

  .operation.scheduled {
    background: #d1fae5;
    border-color: #10b981;
    color: #065f46;
  }

  .operation.dragging {
    opacity: 0.5;
    cursor: grabbing;
  }

  .operation.next-op {
    background: #e0e7ff;
    border-color: #667eea;
    border-width: 2px;
    font-weight: 600;
  }

  .chart-container {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    overflow-x: auto;
  }

  #gantt {
    background: #fff;
    display: block;
  }

  .axis line, .axis path {
    stroke: #ccc;
  }

  .axis text {
    fill: #666;
    font-size: 12px;
  }

  .bar {
    stroke: #333;
    stroke-width: 1px;
    transition: all 0.2s;
    cursor: grab;
  }

  .bar:hover {
    stroke-width: 2px;
    filter: brightness(1.1);
  }

  .bar.dragging {
    opacity: 0.5;
    cursor: grabbing;
  }

  .drop-zone {
    fill: #667eea;
    opacity: 0.2;
    stroke: #667eea;
    stroke-width: 2;
    stroke-dasharray: 5,5;
  }

  .drop-zone.invalid {
    fill: #ef4444;
    stroke: #ef4444;
  }

  .timeline-hover {
    fill: #f3f4f6;
    opacity: 0.5;
    pointer-events: none;
  }

  .conflict-warning {
    fill: #fef3c7;
    stroke: #f59e0b;
    stroke-width: 2;
    opacity: 0.6;
  }

  .operation-label {
    fill: #000;
    font-size: 11px;
    text-anchor: middle;
    alignment-baseline: central;
    pointer-events: none;
    font-weight: 600;
  }

  .tooltip {
    position: absolute;
    padding: 10px 14px;
    background: #333;
    color: #fff;
    font-size: 12px;
    border-radius: 8px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    font-weight: 400;
    z-index: 1000;
    max-width: 250px;
  }

  .instructions {
    background: #e0e7ff;
    border-left: 4px solid #667eea;
    padding: 12px;
    border-radius: 8px;
    font-size: 13px;
    line-height: 1.6;
    color: #333;
  }

  .instructions strong {
    color: #667eea;
  }

  .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.7);
    z-index: 2000;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }

  .modal.show {
    display: flex;
  }

  .modal-content {
    background: white;
    border-radius: 16px;
    padding: 40px;
    max-width: 600px;
    width: 100%;
    text-align: center;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
  }

  .modal-content h2 {
    margin: 0 0 20px 0;
    font-size: 32px;
    color: #333;
  }

  .modal-content p {
    font-size: 16px;
    color: #666;
    margin-bottom: 20px;
    line-height: 1.6;
  }

  .modal-content h3 {
    margin-top: 24px;
    margin-bottom: 12px;
    color: #333;
    font-size: 18px;
  }

  .modal-content ul {
    margin: 12px 0;
    padding-left: 24px;
  }

  @media (max-width: 1024px) {
    .top-panels, .bottom-panels {
      grid-template-columns: 1fr;
    }
  }

  .help-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #667eea;
    color: white;
    font-size: 12px;
    font-weight: 700;
    cursor: help;
    margin-left: 8px;
  }

  .machine-row {
    position: relative;
  }

  .conflict-indicator {
    fill: #ef4444;
    opacity: 0.3;
  }

  .grid-line {
    stroke: #e5e7eb;
    stroke-width: 1;
    stroke-dasharray: 2,2;
  }
</style>
</head>
<body>

<div class="container">
  <div class="header">
    <h1>üéÆ Job Shop Scheduling Game</h1>
    <div class="stats">
      <div class="stat">
        <div class="stat-label">Machines</div>
        <div class="stat-value" id="machineDisplay">3</div>
      </div>
      <div class="stat">
        <div class="stat-label">Makespan</div>
        <div class="stat-value" id="makespanDisplay">0</div>
      </div>
      <div class="stat">
        <div class="stat-label">Jobs Done</div>
        <div class="stat-value" id="jobsDisplay">0/3</div>
      </div>
    </div>
  </div>

  <div class="game-area">
    <div class="top-panels">
      <div class="panel">
        <h2>Setup</h2>
        <label style="display: block; margin-bottom: 10px; font-size: 13px; color: #666;">
          Number of Machines: <strong id="machineCount">3</strong>
        </label>
        <input type="range" id="machineSlider" min="2" max="6" value="3" 
               style="width: 100%; margin-bottom: 15px;" onchange="updateMachineCount()">
        
        <label style="display: block; margin-bottom: 10px; font-size: 13px; color: #666;">
          Number of Jobs: <strong id="jobCount">3</strong>
        </label>
        <input type="range" id="jobSlider" min="2" max="8" value="3" 
               style="width: 100%; margin-bottom: 15px;" onchange="updateJobCount()">
        
        <button id="generateBtn">üé≤ Generate New Problem</button>
      </div>

      <div class="panel">
        <h2>Jobs</h2>
        <div class="instructions">
          <strong>Drag blue operations</strong> to their designated machine row. Each operation must go on a <strong>specific machine</strong> - you choose the timing!
          <div style="margin-top: 10px; font-size: 11px; padding: 8px; background: #f9fafb; border-radius: 4px;">
            <div style="margin-bottom: 4px;">üîµ <strong>Blue</strong> = Next to schedule (e.g., "Op1 ‚Üí Machine A")</div>
            <div style="margin-bottom: 4px;">üü¢ <strong>Green</strong> = Already scheduled (e.g., "J1-Op1")</div>
            <div>‚ö™ <strong>Gray</strong> = Waiting for previous operations</div>
          </div>
        </div>
        <div id="jobsQueue" class="jobs-queue"></div>
      </div>
    </div>

    <div class="bottom-panels">
      <div class="panel">
        <h2>Controls</h2>
        <button id="resetBtn" class="secondary">üîÑ Reset Schedule</button>
        <button id="autoScheduleBtn">ü§ñ Greedy Schedule</button>
        <button id="optimalBtn">üéØ Try Optimal</button>
        <button id="helpBtn" class="secondary">‚ùì How to Play</button>
      </div>

      <div class="chart-container">
        <svg id="gantt"></svg>
      </div>
    </div>
  </div>
</div>

<div id="tooltip" class="tooltip"></div>

<!-- Help Modal -->
<div id="helpModal" class="modal">
  <div class="modal-content" style="text-align: left;">
    <h2 style="text-align: center;">üìñ How to Play</h2>
    
    <h3>üéØ Objective</h3>
    <p>Schedule all jobs to minimize the total completion time (makespan). This is a classic <strong>Job Shop Scheduling Problem</strong>.</p>
    
    <h3>üéÆ How to Schedule</h3>
    <p><strong>Drag from Queue:</strong> Grab the blue highlighted operation (e.g., "Op1 ‚Üí Machine A") and drag it onto the timeline. You must drop it on the <strong>correct machine row</strong>.</p>
    <p><strong>Move Scheduled Operations:</strong> Drag scheduled operations (labeled "J1-Op1", "J1-Op2", etc.) to different <strong>times</strong> to optimize. You cannot change which machine they're on!</p>
    <p><strong>Remove Operations:</strong> Click on any scheduled operation to remove it (and all subsequent operations from that job).</p>
    
    <h3>‚öôÔ∏è Job Shop Constraints</h3>
    <ul style="line-height: 2;">
      <li><strong>Precedence:</strong> Operations of the same job must be completed in order (1 ‚Üí 2 ‚Üí 3...)</li>
      <li><strong>Machine Assignment:</strong> Each operation MUST be on its designated machine (you can only choose timing)</li>
      <li><strong>No Overlap:</strong> Each machine can only process one operation at a time</li>
      <li>Goal: Minimize makespan (time when last job finishes)</li>
    </ul>
    
    <h3>ü§ñ Algorithms</h3>
    <p><strong>Greedy Schedule:</strong> Simple algorithm that schedules operations as early as possible. Often produces suboptimal solutions.</p>
    <p><strong>Try Optimal:</strong> Better heuristic that prioritizes critical operations first. Usually finds better solutions than greedy.</p>
    <p><em>Note: True optimal solutions require complex algorithms (like branch-and-bound). These are heuristics that often work well!</em></p>
    
    <h3>üé≤ Customization</h3>
    <p>Adjust the number of machines and jobs using the sliders, then click <strong>Generate New Problem</strong> to create a fresh scheduling challenge!</p>
    
    <button onclick="closeHelpModal()" style="margin-top: 20px;">Got it!</button>
  </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
// ============================================================
//  JOB SHOP SCHEDULING GAME
// ============================================================

// Game State
let numMachines = 3;
let numJobs = 3;
let machines = [];
let jobs = [];
let scheduledOperations = []; // { jobId, opIndex, machine, start, duration, color }
let draggedOperation = null; // { jobId, opIndex } or { scheduledIndex }
let dropZone = null; // Visual indicator for where operation will be placed

// Color palette for jobs
const jobColors = [
  "#A8D8EA", "#FFEAA7", "#C3FBD8", "#D4C1EC", "#FFD6E0",
  "#B4E7CE", "#FFC8C8", "#D4A5A5", "#9FA8DA", "#F8BBD0"
];

// Generate random job shop problem
function generateProblem(numM, numJ) {
  numMachines = numM;
  numJobs = numJ;
  
  machines = [];
  for (let i = 0; i < numMachines; i++) {
    machines.push(`Machine ${String.fromCharCode(65 + i)}`);
  }
  
  jobs = [];
  for (let i = 0; i < numJobs; i++) {
    const numOps = Math.floor(Math.random() * numMachines) + 2; // 2 to numMachines operations
    const operations = [];
    
    // Create a random sequence of machines (without immediate repeats)
    const availableMachines = [...machines];
    let lastMachine = null;
    
    for (let j = 0; j < numOps; j++) {
      // Filter out the last machine to avoid consecutive operations on same machine
      const choices = lastMachine 
        ? availableMachines.filter(m => m !== lastMachine)
        : availableMachines;
      
      const machine = choices[Math.floor(Math.random() * choices.length)];
      const duration = Math.floor(Math.random() * 4) + 2; // 2-5 time units
      
      operations.push({ machine, duration });
      lastMachine = machine;
    }
    
    jobs.push({
      id: i + 1,
      color: jobColors[i % jobColors.length],
      operations
    });
  }
  
  scheduledOperations = [];
  draggedOperation = null;
  dropZone = null;
}

// SVG Setup
const margin = { top: 60, right: 50, bottom: 40, left: 120 };
const width = 1000;
const height = 500;
const barHeightRatio = 0.7;

const svg = d3.select("#gantt").attr("width", width).attr("height", height);
const tooltip = d3.select("#tooltip");

const xScale = d3.scaleLinear().range([margin.left, width - margin.right]);
const yScale = d3.scaleBand().range([margin.top, height - margin.bottom]).padding(0.15);

const xAxisG = svg.append("g").attr("class", "x axis").attr("transform", `translate(0, ${height - margin.bottom})`);
const yAxisG = svg.append("g").attr("class", "y axis").attr("transform", `translate(${margin.left},0)`);
const gridG = svg.append("g").attr("class", "grid");

// UI Update Functions
function updateMachineCount() {
  numMachines = parseInt(document.getElementById("machineSlider").value);
  document.getElementById("machineCount").textContent = numMachines;
  document.getElementById("machineDisplay").textContent = numMachines;
}

function updateJobCount() {
  numJobs = parseInt(document.getElementById("jobSlider").value);
  document.getElementById("jobCount").textContent = numJobs;
}

// Initialize new problem
function initializeProblem() {
  generateProblem(numMachines, numJobs);
  
  yScale.domain(machines);
  updateXScale();
  renderAxes();
  renderJobsQueue();
  renderSchedule();
  updateStats();
}

function updateXScale() {
  const maxTime = Math.max(20, ...scheduledOperations.map(op => op.start + op.duration));
  xScale.domain([0, maxTime + 2]);
}

function renderAxes() {
  const xAxis = d3.axisBottom(xScale).tickFormat(d => d).ticks(Math.min(20, xScale.domain()[1]));
  const yAxis = d3.axisLeft(yScale);
  
  xAxisG.transition().duration(300).call(xAxis);
  yAxisG.call(yAxis);
  
  // Grid lines
  gridG.selectAll(".grid-line").remove();
  const gridLines = gridG.selectAll(".grid-line")
    .data(xScale.ticks(Math.min(20, xScale.domain()[1])))
    .enter()
    .append("line")
    .attr("class", "grid-line")
    .attr("x1", d => xScale(d))
    .attr("x2", d => xScale(d))
    .attr("y1", margin.top)
    .attr("y2", height - margin.bottom);
}

function renderJobsQueue() {
  const queueDiv = document.getElementById("jobsQueue");
  queueDiv.innerHTML = "";
  
  jobs.forEach(job => {
    const scheduledCount = scheduledOperations.filter(op => op.jobId === job.id).length;
    const allScheduled = scheduledCount >= job.operations.length;
    
    const card = document.createElement("div");
    card.className = "job-card";
    card.style.borderLeftColor = job.color;
    
    const title = document.createElement("div");
    title.className = "job-title";
    title.textContent = `Job ${job.id} (${scheduledCount}/${job.operations.length})`;
    title.style.color = job.color;
    if (allScheduled) {
      title.textContent += " ‚úì";
    }
    card.appendChild(title);
    
    const opsDiv = document.createElement("div");
    opsDiv.className = "operations";
    job.operations.forEach((op, idx) => {
      const isScheduled = scheduledOperations.some(sop => sop.jobId === job.id && sop.opIndex === idx);
      const canSchedule = idx === scheduledCount; // Can only schedule the next operation
      
      const opDiv = document.createElement("div");
      opDiv.className = "operation";
      if (isScheduled) opDiv.classList.add("scheduled");
      if (canSchedule && !isScheduled) opDiv.classList.add("next-op");
      
      opDiv.innerHTML = `<strong>Op${idx + 1}</strong> ‚Üí ${op.machine} <span style="opacity: 0.7;">(${op.duration}h)</span>`;
      
      // Make draggable only if it's the next operation to schedule
      if (canSchedule && !isScheduled) {
        opDiv.draggable = true;
        opDiv.title = `Drag to ${op.machine} timeline`;
        opDiv.ondragstart = (e) => {
          draggedOperation = { jobId: job.id, opIndex: idx, fromQueue: true };
          opDiv.classList.add("dragging");
          e.dataTransfer.effectAllowed = "move";
        };
        opDiv.ondragend = (e) => {
          opDiv.classList.remove("dragging");
          draggedOperation = null;
          removeDropZone();
        };
      } else if (isScheduled) {
        opDiv.title = `Scheduled on ${op.machine}`;
      } else {
        opDiv.title = `Complete previous operations first`;
      }
      
      opsDiv.appendChild(opDiv);
    });
    card.appendChild(opsDiv);
    
    queueDiv.appendChild(card);
  });
}

function renderSchedule() {
  updateXScale();
  renderAxes();
  
  const barHeight = yScale.bandwidth() * barHeightRatio;
  
  // Bind data
  const bars = svg.selectAll(".operation-bar")
    .data(scheduledOperations, (d, i) => `${d.jobId}-${d.opIndex}`);
  
  // Exit
  bars.exit().remove();
  
  // Enter + Update
  const barsEnter = bars.enter()
    .append("g")
    .attr("class", "operation-bar");
  
  barsEnter.append("rect").attr("class", "bar");
  barsEnter.append("text").attr("class", "operation-label");
  
  const barsMerged = barsEnter.merge(bars);
  
  // Make bars draggable
  barsMerged.each(function(d, i) {
    const bar = d3.select(this);
    const rect = bar.select("rect");
    
    // Store the operation index for drag operations
    rect.attr("data-sched-index", i);
    
    rect
      .attr("x", xScale(d.start))
      .attr("y", yScale(d.machine) + (yScale.bandwidth() - barHeight) / 2)
      .attr("width", xScale(d.start + d.duration) - xScale(d.start))
      .attr("height", barHeight)
      .attr("fill", d.color)
      .attr("rx", 4)
      .on("mouseenter", function(event, opData) {
        tooltip.html(`<strong>Job ${opData.jobId} - Operation ${opData.opIndex + 1}</strong><br>
                      Machine: ${opData.machine}<br>
                      Duration: ${opData.duration}h<br>
                      Time: ${opData.start} ‚Üí ${opData.start + opData.duration}<br>
                      <em>Drag to move, Click to remove</em>`)
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY - 20) + "px")
          .style("opacity", 1);
      })
      .on("mouseleave", function() {
        tooltip.style("opacity", 0);
      })
      .on("click", function(event, opData) {
        event.stopPropagation();
        removeOperation(opData.jobId, opData.opIndex);
      })
      .call(d3.drag()
        .on("start", function(event, opData) {
          draggedOperation = { 
            scheduledIndex: i,
            jobId: opData.jobId, 
            opIndex: opData.opIndex,
            fromQueue: false 
          };
          d3.select(this).classed("dragging", true);
          tooltip.style("opacity", 0);
        })
        .on("drag", function(event) {
          // For scheduled operations, only show time adjustment (same machine)
          updateDropZone(event.x, event.y);
        })
        .on("end", function(event) {
          d3.select(this).classed("dragging", false);
          
          if (draggedOperation && !draggedOperation.fromQueue) {
            handleDrop(event.x, event.y);
          }
          
          draggedOperation = null;
          removeDropZone();
          removeHighlights();
        })
      );
    
    bar.select("text")
      .attr("x", xScale(d.start) + (xScale(d.start + d.duration) - xScale(d.start)) / 2)
      .attr("y", yScale(d.machine) + yScale.bandwidth() / 2)
      .text(`J${d.jobId}-Op${d.opIndex + 1}`);
  });
}

function removeOperation(jobId, opIndex) {
  // Remove this operation and all subsequent operations for this job
  scheduledOperations = scheduledOperations.filter(op => 
    !(op.jobId === jobId && op.opIndex >= opIndex)
  );
  
  renderSchedule();
  renderJobsQueue();
  updateStats();
}

// Drop zone visual feedback
function updateDropZone(x, y) {
  removeDropZone();
  
  if (!draggedOperation) return;
  
  const time = Math.max(0, Math.round(xScale.invert(x)));
  const machine = getMachineAtY(y);
  
  if (!machine) return;
  
  const job = jobs.find(j => j.id === draggedOperation.jobId);
  const operation = job.operations[draggedOperation.opIndex];
  const duration = operation.duration;
  
  // Check if this is the correct machine for this operation
  const isValidMachine = machine === operation.machine;
  
  // Show drop zone
  const barHeight = yScale.bandwidth() * barHeightRatio;
  svg.append("rect")
    .attr("class", isValidMachine ? "drop-zone" : "drop-zone invalid")
    .attr("x", xScale(time))
    .attr("y", yScale(machine) + (yScale.bandwidth() - barHeight) / 2)
    .attr("width", xScale(time + duration) - xScale(time))
    .attr("height", barHeight)
    .attr("rx", 4);
  
  // Add warning text if wrong machine
  if (!isValidMachine) {
    svg.append("text")
      .attr("class", "drop-zone")
      .attr("x", xScale(time + duration/2))
      .attr("y", yScale(machine) + yScale.bandwidth() / 2)
      .attr("text-anchor", "middle")
      .attr("fill", "#dc2626")
      .attr("font-size", "12px")
      .attr("font-weight", "600")
      .text(`‚ùå Op${draggedOperation.opIndex + 1} needs ${operation.machine}`);
  }
}

function removeDropZone() {
  svg.selectAll(".drop-zone").remove();
}

function getMachineAtY(y) {
  for (let machine of machines) {
    const yPos = yScale(machine);
    if (y >= yPos && y <= yPos + yScale.bandwidth()) {
      return machine;
    }
  }
  return null;
}

function handleDrop(x, y) {
  if (!draggedOperation) return;
  
  const time = Math.max(0, Math.round(xScale.invert(x)));
  const machine = getMachineAtY(y);
  
  if (!machine) return;
  
  const job = jobs.find(j => j.id === draggedOperation.jobId);
  const operation = job.operations[draggedOperation.opIndex];
  
  // ENFORCE CONSTRAINT: Operation must be on its designated machine
  if (machine !== operation.machine) {
    alert(`‚ùå Invalid placement!\n\nJob ${job.id}, Operation ${draggedOperation.opIndex + 1} must be performed on ${operation.machine}, not ${machine}.`);
    return;
  }
  
  if (draggedOperation.fromQueue) {
    // Check precedence constraint
    const scheduledCount = scheduledOperations.filter(op => op.jobId === draggedOperation.jobId).length;
    if (draggedOperation.opIndex !== scheduledCount) {
      alert(`‚ùå Precedence violation!\n\nYou must schedule operations in order. Complete operation ${scheduledCount + 1} first.`);
      return;
    }
    
    // Scheduling from queue
    scheduleOperation(draggedOperation.jobId, draggedOperation.opIndex, machine, time);
  } else {
    // Moving existing operation - check if it violates precedence
    const schedIdx = draggedOperation.scheduledIndex;
    if (schedIdx !== undefined && schedIdx < scheduledOperations.length) {
      // Check if new timing violates precedence with previous operation
      if (draggedOperation.opIndex > 0) {
        const prevOp = scheduledOperations.find(op => 
          op.jobId === draggedOperation.jobId && op.opIndex === draggedOperation.opIndex - 1
        );
        if (prevOp && time < prevOp.start + prevOp.duration) {
          alert(`‚ùå Precedence violation!\n\nOperation ${draggedOperation.opIndex + 1} cannot start before operation ${draggedOperation.opIndex} finishes (at time ${prevOp.start + prevOp.duration}).`);
          return;
        }
      }
      
      // Check if new timing violates precedence with next operation
      const nextOp = scheduledOperations.find(op => 
        op.jobId === draggedOperation.jobId && op.opIndex === draggedOperation.opIndex + 1
      );
      if (nextOp && time + operation.duration > nextOp.start) {
        alert(`‚ùå Precedence violation!\n\nOperation ${draggedOperation.opIndex + 1} would finish after operation ${draggedOperation.opIndex + 2} starts.`);
        return;
      }
      
      // Check for machine conflicts
      const conflicts = scheduledOperations.filter((op, idx) => 
        idx !== schedIdx &&
        op.machine === machine && 
        !(time >= op.start + op.duration || time + operation.duration <= op.start)
      );
      
      if (conflicts.length > 0) {
        alert(`‚ùå Machine conflict!\n\nThis placement overlaps with another operation on ${machine}.`);
        return;
      }
      
      scheduledOperations[schedIdx].start = time;
      
      renderSchedule();
      renderJobsQueue();
      updateStats();
    }
  }
}

// Highlight machine rows during drag
function highlightMachineRows() {
  svg.selectAll(".machine-highlight").remove();
  
  if (!draggedOperation) return;
  
  const job = jobs.find(j => j.id === draggedOperation.jobId);
  const operation = job.operations[draggedOperation.opIndex];
  const requiredMachine = operation.machine;
  
  const barHeight = yScale.bandwidth();
  
  machines.forEach(machine => {
    const isCorrect = machine === requiredMachine;
    svg.append("rect")
      .attr("class", "machine-highlight")
      .attr("x", margin.left)
      .attr("y", yScale(machine))
      .attr("width", width - margin.left - margin.right)
      .attr("height", barHeight)
      .attr("fill", isCorrect ? "#10b981" : "#ef4444")
      .attr("opacity", 0.1)
      .style("pointer-events", "none");
  });
}

function removeHighlights() {
  svg.selectAll(".machine-highlight").remove();
}

// Enable SVG as drop target for queue operations
svg.on("dragover", function(event) {
  event.preventDefault();
  if (draggedOperation && draggedOperation.fromQueue) {
    highlightMachineRows();
    const coords = d3.pointer(event);
    updateDropZone(coords[0], coords[1]);
  }
});

svg.on("drop", function(event) {
  event.preventDefault();
  if (draggedOperation && draggedOperation.fromQueue) {
    const coords = d3.pointer(event);
    handleDrop(coords[0], coords[1]);
    draggedOperation = null;
    removeDropZone();
    removeHighlights();
  }
});

svg.on("dragleave", function(event) {
  removeDropZone();
  removeHighlights();
});

function canScheduleOperation(jobId, opIndex, machine, start) {
  const job = jobs.find(j => j.id === jobId);
  const operation = job.operations[opIndex];
  
  // Check if this is the next operation for the job
  const scheduledForJob = scheduledOperations.filter(op => op.jobId === jobId).length;
  if (opIndex !== scheduledForJob) return false;
  
  // Check if machine matches
  if (operation.machine !== machine) return false;
  
  // Check if previous operation is done
  if (opIndex > 0) {
    const prevOp = scheduledOperations.find(op => op.jobId === jobId && op.opIndex === opIndex - 1);
    if (!prevOp || start < prevOp.start + prevOp.duration) return false;
  }
  
  // Check for conflicts on this machine
  const end = start + operation.duration;
  const conflicts = scheduledOperations.filter(op => 
    op.machine === machine && 
    !(op.start >= end || op.start + op.duration <= start)
  );
  
  return conflicts.length === 0;
}

function findEarliestSlot(jobId, opIndex, machine) {
  const job = jobs.find(j => j.id === jobId);
  const operation = job.operations[opIndex];
  
  // Start from when previous operation finishes
  let earliestStart = 0;
  if (opIndex > 0) {
    const prevOp = scheduledOperations.find(op => op.jobId === jobId && op.opIndex === opIndex - 1);
    if (prevOp) earliestStart = prevOp.start + prevOp.duration;
  }
  
  // Find gaps in machine schedule
  const machineOps = scheduledOperations
    .filter(op => op.machine === machine)
    .sort((a, b) => a.start - b.start);
  
  for (let t = earliestStart; t <= xScale.domain()[1]; t++) {
    if (canScheduleOperation(jobId, opIndex, machine, t)) {
      return t;
    }
  }
  
  // If no slot found, add at the end
  if (machineOps.length === 0) return earliestStart;
  const lastOp = machineOps[machineOps.length - 1];
  return Math.max(earliestStart, lastOp.start + lastOp.duration);
}

function scheduleOperation(jobId, opIndex, machine, start) {
  const job = jobs.find(j => j.id === jobId);
  const operation = job.operations[opIndex];
  
  // Validate machine assignment
  if (machine !== operation.machine) {
    console.error(`Operation must be on ${operation.machine}`);
    return;
  }
  
  // Auto-adjust start time if it creates conflicts or violates precedence
  const adjustedStart = findValidStartTime(jobId, opIndex, machine, start);
  
  scheduledOperations.push({
    jobId,
    opIndex,
    machine,
    start: adjustedStart,
    duration: operation.duration,
    color: job.color
  });
  
  renderSchedule();
  renderJobsQueue();
  updateStats();
}

function findValidStartTime(jobId, opIndex, machine, preferredStart) {
  const job = jobs.find(j => j.id === jobId);
  const operation = job.operations[opIndex];
  
  // Must start after previous operation
  let earliestStart = preferredStart;
  if (opIndex > 0) {
    const prevOp = scheduledOperations.find(op => op.jobId === jobId && op.opIndex === opIndex - 1);
    if (prevOp) {
      earliestStart = Math.max(earliestStart, prevOp.start + prevOp.duration);
    }
  }
  
  // Find a slot that doesn't conflict with other operations on this machine
  let testStart = earliestStart;
  let maxAttempts = 100;
  
  while (maxAttempts-- > 0) {
    const testEnd = testStart + operation.duration;
    const conflicts = scheduledOperations.filter(op => 
      op.machine === machine && 
      !(op.start >= testEnd || op.start + op.duration <= testStart) &&
      !(op.jobId === jobId && op.opIndex === opIndex) // Ignore self when moving
    );
    
    if (conflicts.length === 0) {
      return testStart;
    }
    
    // Move to after the conflicting operation
    const nextSlot = Math.max(...conflicts.map(op => op.start + op.duration));
    testStart = nextSlot;
  }
  
  return preferredStart; // Give up and use preferred start
}

function updateStats() {
  const makespan = scheduledOperations.length > 0 
    ? Math.max(...scheduledOperations.map(op => op.start + op.duration))
    : 0;
  
  document.getElementById("makespanDisplay").textContent = makespan;
  
  // Count how many jobs are fully scheduled
  const completedJobs = jobs.filter(job => 
    scheduledOperations.filter(op => op.jobId === job.id).length === job.operations.length
  ).length;
  
  document.getElementById("jobsDisplay").textContent = `${completedJobs}/${jobs.length}`;
}

function autoSchedule() {
  // Simple greedy algorithm: schedule operations as early as possible
  scheduledOperations = [];
  
  let anyScheduled = true;
  while (anyScheduled) {
    anyScheduled = false;
    
    for (let job of jobs) {
      const nextOpIndex = scheduledOperations.filter(op => op.jobId === job.id).length;
      if (nextOpIndex < job.operations.length) {
        const operation = job.operations[nextOpIndex];
        const start = findEarliestSlot(job.id, nextOpIndex, operation.machine);
        
        scheduledOperations.push({
          jobId: job.id,
          opIndex: nextOpIndex,
          machine: operation.machine,
          start,
          duration: operation.duration,
          color: job.color
        });
        
        anyScheduled = true;
      }
    }
  }
  
  renderSchedule();
  renderJobsQueue();
  updateStats();
}

function tryOptimal() {
  // Try a better heuristic: EDD (Earliest Due Date) + Critical Path
  scheduledOperations = [];
  
  // Create a list of all operations with their dependencies
  const allOps = [];
  jobs.forEach(job => {
    job.operations.forEach((op, idx) => {
      allOps.push({
        jobId: job.id,
        opIndex: idx,
        machine: op.machine,
        duration: op.duration,
        color: job.color,
        // Calculate criticality based on remaining operations
        criticality: job.operations.length - idx
      });
    });
  });
  
  // Sort by criticality (more critical operations first)
  allOps.sort((a, b) => b.criticality - a.criticality);
  
  // Schedule operations in criticality order
  allOps.forEach(op => {
    const start = findEarliestSlot(op.jobId, op.opIndex, op.machine);
    scheduledOperations.push({
      jobId: op.jobId,
      opIndex: op.opIndex,
      machine: op.machine,
      start,
      duration: op.duration,
      color: op.color
    });
  });
  
  renderSchedule();
  renderJobsQueue();
  updateStats();
}

function resetSchedule() {
  scheduledOperations = [];
  draggedOperation = null;
  removeDropZone();
  renderSchedule();
  renderJobsQueue();
  updateStats();
}

function closeHelpModal() {
  document.getElementById("helpModal").classList.remove("show");
}

// Event Listeners
document.getElementById("resetBtn").onclick = resetSchedule;
document.getElementById("autoScheduleBtn").onclick = autoSchedule;
document.getElementById("optimalBtn").onclick = tryOptimal;
document.getElementById("generateBtn").onclick = initializeProblem;
document.getElementById("helpBtn").onclick = () => {
  document.getElementById("helpModal").classList.add("show");
};

// Initialize game
initializeProblem();

// Show help on first load
setTimeout(() => {
  document.getElementById("helpModal").classList.add("show");
}, 500);
</script>
</body>
</html>

